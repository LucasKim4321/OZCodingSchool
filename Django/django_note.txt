Django (장고)

1. ORM(Object relational Mapping) -> DB구조와 쿼리를 할 수 있는 기능
2. Authentication & Authorization -> 인증 허가(로그인 관련 기능)
3. Admin Interface -> 관리자 인터페이스 자동 생성 지원
4. internationalization -> 국제화, 번역 기능
5. URL Routing -> URL을 이용한 페이지 처리
6. Template Engine

MVT 구조 (MVC구조 이전의 구조)

Model : DB관련 기능 수행
View : 실질적인 메인 알고리즘
Template : 유저들에게 보여주는 화면단

장점

개발 속도가 빠름
코드 재사용 및 모듈화: 유연
안전한 웹 애플리케이션 구축: 보안


단점
잘 쓰려면 숙련 및 개념 탑재 필요
Django적인 개발 문법이 필요.
익혀야하는 개념들이 조금 복잡함.

쓰는 이유?
Flask나 FastAPI는 여러개 패키지를 가져다 써야하는데 반해, 모두 준비가 되어 있음
개발 시간을 줄여주는 관리자 페이지의 마법!!
개발 시간 및 코드를 줄여주는 모듈화의 마법?
획일화된 구조로 누가 코드를 봐도 적응 시간이 빠름
수 많은 패키지와 잘 구축된 커뮤니티

브라우저 -> Web Server -> urls.py -> Views.py(처리) -> Model.py -> DB
DB -> Model.py -> Views.py -> Template -> Views.py -> Web Server -> 브라우저

--------------
장고 시작하기
--------------

 # oz라는 이름으로 가상환경 생성
 pyenv virtualenv 3.12.1 oz
 
 # 가상환경 실행
 pyenv local oz
 
 # poetry 설치
 brew install poetry
 
 # poetry 초기화
 # Package name은 oz_bookmark로 설정
 # Author에만 n을 입력하고 나머지는 전부 Enter를 눌러 진행합니다.
 poetry init

이것만 하고 나머진 엔터로 스킵해도 무관
Package name [bookmark]:  이름입력
Version [0.1.0]:  엔터
Description []:  엔터
Author [LucasKim4321 <xowls0131@naver.com>, n to skip]:  n입력

poetry add django 최신버전 설치
poetry add django==5.0.3 원하는 버전 설치

서버 실행
python3 manage.py runserver


urls.py 기본 구조

def index(request):
    return HttpResponse('<h1>hello2</h1>')

urlpatterns = [
    path('admin/', admin.site.urls), # 기본적으로 만들어져있는 admin페이지
    path('url경로', 사용할 함수),
    path('', index),
    path('book_list/<int:num>/', book),
    path('language/<str:lang>/', language),  # <str>을 쓰면 모든 문자열이 인식되서 모든 경로에 영향을 끼침
]

앱(app) 생성
python3 manage.py startapp 앱이름
python3 manage.py startapp bookmark
프로젝트 폴더에 설정한 이름의 앱폴더가 생성됨

앱 하위 요소
models.py DB관련된 테이블, 컬런 관리
views.py 메인 알고리즘
tests.py 테스트 코드를
app.py 장고 앱 설정
admin.py 관리자 기능 설정
__init__.py 파이선 패키지 만드는 파일
migrations models.py 변경사항 기록

앱 등록
INSTALLED_APPS = [
    '앱이름',
]

DB Browser for SQLite 설치
open database
프로젝트 폴더/db.sqlite3

# 앱에 필요한 테이블 admin, auth, contenttypes, sessions
# 마이그레이션하면 오류 내용 없어짐.

# 마이그레이션
# 마이그레이션 파일을 바탕으로 DB에 적용(마이그레이션)하는 과정
python3 manage.py migrate

# 마이그레이션 생성
# 마이그레이션 할 내용을 작성하는 과정
python3 manage.py makemigrations
migrations/migration.py 파일을 생성


admin페이지 관리자 계정 생성
python3 manage.py createsuperuser

장고 페이지 언어 설정
setting.py
LANGUAGE_CODE = 'ko-KR' # 모든 장고 페이지가 한글로 바뀜


-----------------------
    Django ORM
-----------------------

objects => 모델 매니저/ 쿼리를 할 수 있게 해줌

모델의 모든 데이터 가져오기  (SELECT * FROM 테이블명)
Bookmark = 모델명.objects.all()  # 리스트

조건을 만족하는 모델 하나의 데이터 가져오기 (SELECT * FROM 모델명 WHERE id=id LIMIT 1)
Bookmark = 모델명.objects.get(id=id)  # 단일데이터
Bookmark = 모델명.objects.get(pk=pk)  # 단일데이터

조건을 만족하는 모든 모델 데이터 가져오기 (SELECT * FROM 모델명 WHERE id=id)
Bookmark = 모델명.objects.filter(pk=pk)  # 리스트

조건을 만족하는 모든 모델 데이터 가져오기 (SELECT * FROM 모델명 WHERE created_at >= now)
gte : greater than or equal  lte : less than or equal
not = datetime.now()
Bookmark = 모델명.objects.filter(created_at__gte = now)  # 리스트

SELECT * FROM bookmark WHERE name='네이버'
Bookmark = 모델명.objects.filter(name = '네이버')

SELECT * FROM bookmark WHERE name LIKE '%네이버%'
Bookmark = 모델명.objects.filter(name__icontains = '네이버')

# 첫번째 요소 반환
모델명.objects.first()

# 마지막 요소 반환
모델명.objects.last()

# 특정 글자로 시작하는 요소 반환
모델명.objects.filter(name__startswith='네')

# 특정 글자로 끝나는 요소 반환
모델명.objects.filter(name__endswith='버')

# 네이버 또는 다음을 포함하는 요소 반환
모델명.objects.filter(name__in=['네이버','다음'])

# AND 조건
모델명.objects.filter(name='네이버', url__startswith='https://naver')

# 데이터 추가 1
모델명.objects.create(name='야후', url='https://yahoo.com')

# 데이터 추가 2
bookmark = Bookmark(name='야후2', url='https://yahoo.com')  # save()하기전엔 데이터베이스에 반영되지 않음
bookmark.save()
bookmark.id  # save()전엔 id값이 없었는데 save()후 id값이 생김

마지막 출력의 첫번째가 b에 저장됨.
b = _.first()

# id값을 없앰
b.id = None

# save()하면 id값이 없어서 새로운 객체로 인식해서 새로 저장됨.
b.save()

# 특정 데이터 수정
Bookmark.objects.filter(url__icontains='naver.com').update(name='naver')

# 한번에 데이터를 생성해서 쿼리문을 사용하는 횟수를 줄여 부담을 줄임.
# bookmarks = [Bookmark(name=f'테스트 구글 {i}', url='https://google.com') for i in range(10)]
# Bookmark.objects.bulk_create(bookmarks)

Bookmark.objects.bulk_update()


가져오기 실패시 404오류 반환
# 1
try:
    bookmark = Bookmark.objects.get(pk=pk)
except:
    raise Http404
# 2
bookmark = get_object_or_404(Bookmark, pk=pk)


장고 파이선 셀 사용
python3 manage.py shell

나가기
컨트롤 d 또는 exit()


poetry 사용
Poetry는 Python 패키지 및 가상환경을 효율적으로 관리할 수 있도록 도와주는 패키지 관리 도구입니다.
기존의 pip + virtualenv 조합보다 더 강력하고 간편한 방식으로 Python 프로젝트를 관리할 수 있습니다.

# poetry프로젝트 초기화
# pyproject.toml파일이 생성됨. pyproject.toml은 프로젝트의 의존성(패키지), Python 버전, 프로젝트 메타데이터 등을 관리하는 설정 파일입니다.
poetry init

# ipython을 Poetry 환경에 추가합니다.
# 대화형 Python 인터프리터로, python보다 향상된 기능을 제공합니다.
poetry add ipython

poetry add ipython 한 후 파이선 셀을 실행하면 환경이 달라짐
python3 manage.py shell

# Django 개발을 편리하게 만들어주는 확장 기능 모음입니다.
# 추가적인 관리 명령어(manage.py shell_plus 등)와 도구를 제공합니다.
poetry add django-extensions

settings.py
INSTALLED_APPS
'django_extensions', 추가

터미널에서 실행
python3 manage.py shell_plus

shell_plus에선 기본적으로 대부분이 ipmort되어 있음
Bookmark.objects.all() 이렇게 바로 import 안하고 바로 사용 가능


pycharm 명령어 설정
.zshrc에 명령어 등록
echo 'export PATH="/Applications/PyCharm.app/Contents/MacOS:$PATH"' >> ~/.zshrc에
터미널 재시작
source ~/.zshrc


---------------------
session & cookie
---------------------

구분       쿠키                                      세션
저장 위치   클라이언트                                  서버 (클라이언트에는 키만 저장하고 실제 데이터는 서버에 존재)
저장 형식   텍스트                                     Object형
종료 시점   쿠키 저장시 설정                             정확한 종료 시점을 알 수 없다
          (설정하지 않으면 브라우저 종료시)
자원       클라이언트 자원                              서버의 자원
용량 제한   한 도메인당 20개, 쿠키 하나당 4KB, 총 300개     서버가 허용하는 한 용량에 제한이 없음

# 쿠키(cookie)
# visit을 키값으로 쿠키를 가져오고 존재하지 않으면 0 있으면 +1
visits = int(request.COOKIES.get('visits', 0 )) + 1
response =  render(request, 'blog_list.html', context)
response.set_cookie('visits', visits)
return response

# 세션(session)
request.session['count'] = request.session.get('count', 0) +1
context = {
    'blogs': blogs,
    'count': request.session['count'],
}


장고 로그인 기능 구현

url설정
path('accounts/', include('django.contrib.auth.urls')), # include() 장고에 내장된 url사용

html에 설정 {# 장고로 로그인 기능 사용시 토큰 필요함 #}
{% csrf_token %} 

settings.py
# login 성공시 url 설정
LOGIN_REDIRECT_URL = '/'


요구 패키지 목록 생성
pip3 freeze > requirements.txt

패키지 목록 설치
pip install -r requirements.txt

패키지 목록을 최신버전으로 설치
pip install --upgrade -r requirements.txt


-----------------------
    관리자(admin)
-----------------------

특정 모델에 대한 admin기능 활성화
@admin.register(모델명)
class 클래스명(admin.ModelAdmin):
    pass

class Blog(models.Model):
    CATEGORY_CHOICES = (
        ('free','자유'),
        ('travel','여행'),
        ('cat','고양이'),
        ('dog','개'),
    )
    category = models.CharField('카테고리', max_length=20, choices=CATEGORY_CHOICES)  # 첫번째 매개변수 verbose_name(관리자 페이지에서 표시될 이름)
    title = models.CharField('제목', max_length=100)
    content = models.TextField('본문')
    created_at = models.DateTimeField('작성일자', auto_now_add=True)  # 생성시 자동으로 현재 시간 추가
    updated_at = models.DateTimeField('수정일자', auto_now_add=True)

    # 관리자 페이지에서 blog object 라고 표시되는 사항 변경
    def __str__(self):
        return f'[{self.get_category_display()}] {self.title[:10]}'

    class Meta: # 필수는 아니고 admin 등에서 사용 (없어도 무관)
        verbose_name = '블로그'  # verbose_name 따로 지정. 지정하지 않으면 Blog
        verbose_name_plural = '블로그 목록'  # verbose_name_plural 따로 지정. 지정하지 않으면 Blogs


-----------------------
    로그인(login)
-----------------------

# 장고에 내장된 login기능 사용
path('accounts/', include('django.contrib.auth.urls')), # include() 장고에 내장된 url사용

<form method="POST">
    {# 장고로 로그인 기능 사용시 토큰 필요함 #}
    {% csrf_token %}
    {{ form.as_p }}
    <button>로그인</button>
</form>

<form method="POST">
    {% csrf_token %}
    {{ form.as_p }}
    <button>회원가입</button>
</form>

{% if request.user.is_authenticated %}
<form action="{% url 'logout' %}" method="POST" style="display:inline">
    {% csrf_token %}
    <button>로그아웃</button>
</form>
{{ request.user.username }}
{% else %}
<a href="{% url 'signup' %}">회원가입</a>
<a href="{% url 'login' %}">로그인</a>
{% endif %}

# settings.py
# 장고 기본 로그인 기능 이용
# LOGIN_URL = '/accounts/login/'
# 따로 만든 로그인 기능 이용
LOGIN_URL = '/login/'

# login 성공시 url 설정
LOGIN_REDIRECT_URL = '/'
# logout 성공시 url 설정
LOGOUT_REDIRECT_URL = '/'

def sign_up(request):
    # username = request.POST['username'] # POST말고 다른 요청이 들어오면 브라우저에서 오류남.
    # username = request.POST.get('username') # 다른 요청이 들어오면 None이 발생하지만 오류가 나진 않음
    # print('username', username)

    # if request.method == 'POST':
    #     form = UserCreationForm(request.POST) # POST요청 데이터를 여러 처리과정(validation등)을 거친 후 form에 넣음
    #     if form.is_valid(): # 요구 조건 통과 여부 확인
    #         form.save() # 요구 조건이 맞으면 저장  # form에 내용을 DB에 반영하고 해당 데이터의 객체를 반환(리턴)함.
    #         return redirect('/accounts/login/')
    # else:
    #     form = UserCreationForm() # 장고에서 기본적으로 제공해주는 회원가입 폼

    # 이렇게 하면 조건문 안써도 됨.
    form = UserCreationForm(request.POST or None)
    if form.is_valid(): # 요구 조건 통과 여부 확인
        form.save() # 요구 조건이 맞으면 저장
        return redirect(settings.LOGIN_URL)

    context = {
        'form':form,
    }
    return render(request, 'registration/signup.html', context)

# 사용자 지정 로그인
def login(request):
    form = AuthenticationForm(request, request.POST or None)

    if form.is_valid(): # 요구 조건 통과 여부 확인
        django_login(request, form.get_user())  # 로그인을 시도함
        return redirect(reverse('blog_list'))  # html의 {% url 'blog_list' %} 와 동일

    context = {
        'form':form
    }
    return render(request, 'registration/login.html', context)

# 외례키 컬럼 추가
class Blog(models.Model):
    author = models.ForeignKey(User, on_delete=models.CASCADE)  # author_id
    # models.CASCATE => 같이 삭제 => 유저 삭제시 같이 블로그도 같이 삭제
    # models.PROTECT => 삭제가 불가능함 => 유저를 삭제하려고 할 때 블로그가 있으면 유저 삭제가 불가능 (기본값)
    # models.SET_NULL => 널 값을 넣음 => 유저 삭제시 블로그의 author가 Null이 됨.

    # 기존에 없던 author를 외례키로 추가하면 기존 블로그의 author값이 없어서 마이그레이션 할 때 에러남
    # python3 manage.py makemigrations 하면 기존 블로그 데이터에 기본값을 줄건지 물어봄.
    # 1번 기본값 주기 선택 후 기존 데이터의 초기값으로 주어질 id값 선택 하면 정상적으로 마이그레이션 됨.

html에서 외례키 author 불러오는 방법
{{ blog.author.username }}


# extends 기능 사용
# base가 되는 html문서 안에 외부 html문서를 내용으로 채우는 방식
# base.html
<body>
    <div>
        <h1>base title</h1>
    </div>
    {%  block content %}
    {% endblock %}
</body>

# login.html
{% extends 'base.html' %}
{% block content %}
    <form method="POST">
        {# 장고로 로그인 기능 사용시 토큰 필요함 #}
        {% csrf_token %}
        {{ form.as_p }}
        <button>로그인</button>
    </form>
{% endblock %}


# order_by('정렬 기준 값') 오름차순(ASC)으로 정렬.  값에 '-'를 붙이면 내림차순(DESC)정렬
blogs = Blog.objects.all().order_by('-created_at')


# 게시글 생성 기능 구현
@login_required # settings.py에 설정된 LOGIN_URL로 리다이렉트
def blog_create(request):
    # 로그인되어 있지 않으면 로그인화면으로 리다이렉트
    # if not request.user.is_authenticated:
    #     return redirect(reverse('login'))
    
    form = BlogForm(request.POST or None)
    if form.is_valid():
        # form.save() : form에 내용을 DB에 반영하고 해당 데이터의 객체를 반환(리턴)함.
        blog = form.save(commit=False)  # DB에 반영하지 않고 객체만 반환함.
        blog.author = request.user  # 작성자에 로그인된 유저를 넣음
        blog.save()  # DB에 반영
        return redirect(reverse('blog_detail', kwargs={'pk':blog.pk}))

    context = {
        'form':form,
    }

    return render(request, 'blog_create.html', context)

# 사용자 지정 폼 정의
from django import forms
from blog.models import Blog

class BlogForm(forms.ModelForm):
    class Meta:
        model = Blog
        # fields = '__all__'  # 전체 적용
        fields = ('title','content')  # 원하는 것만 적용

# blog_create.html
{% extends 'base.html' %}
{% block content %}
<form method="POST">
    <h1>블로그 작성</h1>
    {% csrf_token %}
    {{ form.as_p }}
    <button>생성</button>
</form>
{% endblock %}


# 게시글 수정 기능 구현
@login_required
def blog_update(request, pk):
    # blog = get_object_or_404(Blog, pk=pk)
    # if request.user != blog.author:
    #     raise Http404
    blog = get_object_or_404(Blog, pk=pk, author=request.user) # pk와 author가 일치하는 데이터만 가져옴

    form = BlogForm(request.POST or None, instance=blog)  # instance 폼의 항목에 맞게 blog에서 데이터를 불러옴
    if form.is_valid():
        # form.save() : form에 내용을 DB에 반영하고 해당 데이터의 객체를 반환(리턴)함.
        blog = form.save()  # DB에 반영
        return redirect(reverse('blog_detail', kwargs={'pk':blog.pk}))

    context = {
        'blog':blog,
        'form':form,
   }

    return render(request, 'blog_update.html', context)

# blog_update.html
{% extends 'base.html' %}
{% block content %}
<form method="POST">
    <h1>블로그 수정</h1>
    {% csrf_token %}
    {{ form.as_p }}
    <button>수정</button>
</form>
{% endblock %}


--------------------------------
# 페이지 기능 (pagination) 구현
--------------------------------

# blog/views.py
def blog_list(request):
    paginator = Paginator(blogs, 10)  # blogs를 10개 단위로 페이지를 만듬
    page = request.GET.get('page')  # 파라미터 값으로 page값이 들어오면 page값 반환. 0이거나 최대페이지를 초과하는 페이지는 마지막 페이지를 반환. 숫자가 아닌값이 들어오면 첫페이지
    page_object = paginator.get_page(page)  # 해당 페이지로 이동

    context = {
        'page_object': page_object,
    }

    return render(request, 'blog_list.html', context)

# blog_list.html
{% for blog in page_object %}
    <p>
        <a href="{% url 'blog_detail' blog.pk %}">
            ({{ blog.id }}) {{ blog.title }} <small>by {{ blog.author.username }}</small> - <small>{{ blog.created_at | date:"Y-m-d"}}</small>
        </a>
    </p>
{% endfor %}

# v1
<div style="text-align:center;">
    {% if page_object.has_previous %}  {# 이전 페이지 존재시 #}
    <a href="?page=1">&laquo; 첫번째</a>
    <a href="?page={{ page_object.previous_page_number }}">이전</a>
    {% endif %}
    <span>
        {# 총 페이지 중에 현재 몇 페이지인지 표시 #}
        Page {{ page_object.number }} of {{ page_object.paginator.num_pages }}
    </span>
    {% if page_object.has_next %} {# 다음 페이지 존재시 #}
        <a href="?page={{ page_object.next_page_number }}">다음</a>
        <a href="?page={{ page_object.paginator.num_pages }}">마지막 &raquo;</a>
    {% endif %}
</div>

# v2
<div style="text-align:center;">
    {% if page_object.has_previous %}  {# 이전 페이지 존재시 #}
        <a href="?page=1">&laquo; 첫번째</a>
        <a href="?page={{ page_object.previous_page_number }}">이전</a>
    {% endif %}

    {# 총 페이지 중에 현재 몇 페이지인지 표시 #}
    {# <span> Page {{ page_object.number }} of {{ page_object.paginator.num_pages }} </span> #}

    {# 현재페이지 -2 > 1 이면 ... #}
    {% if page_object.number|add:-2 > 1 %}
        <a href="?page={{ page_object.number|add:-3 }}">&hellip;</a>
    {% endif %}
    {% for i in page_object.paginator.page_range %}
        {% if page_object.number == i %}
            <span>(현재페이지)</span>
        {# 현재페이지 - 2 <= 현재페이지 <= 현재페이지 + 2 #}
        {% elif page_object.number|add:-2 <= i and i <= page_object.number|add:2 %}
            <a href="?page={{ i }}">{{ i }}</a>
        {% endif %}
    {% endfor %}
    {# 최대페이지 > 현재페이지 + 2 이면 ... #}
    {% if page_object.paginator.num_pages > page_object.number|add:2 %}
        <a href="?page={{ page_object.number|add:3 }}">&hellip;</a>
    {% endif %}

    {% if page_object.has_next %} {# 다음 페이지 존재시 #}
        <a href="?page={{ page_object.next_page_number }}">다음</a>
        <a href="?page={{ page_object.paginator.num_pages }}">마지막 &raquo;</a>
    {% endif %}
</div>


------------------
# 검색 기능 구현
------------------

# blog/views.py
q = request.GET.get('q')
if q:
    blogs = blogs.filter(Q(title__icontains=q) | Q(content__icontains=q))
    # blogs = blogs.filter(title__icontains=q)
    
# blog_list.html
<div style="text-align:center; margin: 20px 0;">
    <form method="get">
        <input name="q" type="text" placeholder="검색어를 입력하세요." value="{% if request.GET.q %}{{ request.GET.q }}{% endif %}">
        <button>검색</button>
    </form>
</div>


------------------
# 삭제 기능 구현
------------------

# blog/views.py
@login_required
@require_http_methods(['POST'])
def blog_delete(request, pk):
    # if request.method != 'POST':
    #     raise Http404

    blog = get_object_or_404(Blog, pk=pk, author=request.user) # pk와 author가 일치하는 데이터만 가져옴
    blog.delete()

    return redirect(reverse('blog_list'))

# blog_detail.html
<a href="{% url 'blog_delete' blog.pk %}">삭제</a>
<form action="{% url 'blog_delete' blog.pk %}" method="POST" style="display:inline">
    {% csrf_token %}
    <button>삭제</button>
</form>


--------------------------------
# CBV (Class Based View)
--------------------------------

CBV(Class Based View)

장점
- 재사용 용이
- 잘 쓸 경우 코드가 짧아지는 효과
- 구조가 나눠져 있어 코드 가독성증가

단점
- 배워야 하는게 많아짐
- 잘 모르고 쓸 경우 너무 어렵고 복잡함

기존의 블로그 프로젝트는  FBV (Function Based View) 형태


# 조회 (ListView)

# views.py
class BlogListView(ListView):
    # model = Blog # object.all()을 사용해 데이터를 가져옴.
    # ordering = ('-created_at',)  # 정렬 옵션
    queryset = Blog.objects.all().order_by('-created_at')  # 사용자 지정 query
    template_name = 'blog_list.html'  # render()할 페이지
    paginate_by = 10  # paginator 설정

    # 사용자 지정 쿼리셋
    def get_queryset(self):
        queryset = super().get_queryset()  # 쿼리 셋을 가져옴
        q = self.request.GET.get('q')
        if q:
            queryset = queryset.filter(
                Q(title__icontains=q) |
                Q(content__icontains = q)
            )
        return queryset

# context = {
#     "paginator": paginator,
#     "page_obj": page,
#     "is_paginated": is_paginated,
#     "object_list": queryset,
# }

# cofig/urls.py
path('cb/', cb_views.BlogListView.as_view(), name = 'cb_blog_list'),


# 상세 (DetailView)

# views.py
class BlogDetailView(DetailView):
    model = Blog
    template_name = 'blog_detail.html'
    # pk_url_kwarg = 'blog_id'  # url에서 pk말고 다른 이름으로 id값 가져올 시 설정

    # 데이터 처리하는 방법 1
    # 사용자 지정 쿼리셋
    # def get_queryset(self):
    #     queryset = super().get_queryset()
    #     return queryset.filter(id__lte=50)

    # 데이터 처리하는 방법 2
    # def get_object(self, queryset=None):
    #     # object = self.model.objects.get(pk=self.kwargs.get('pk'))
    #     object = super().get_object()
    #     if object.id > 50:
    #         raise Http404("해당 객체에 대한 접근이 금지되어있습니다.")
    #     return object

    # 사용자 지정 context
    # def get_context_data(self, **kwargs):
    #     context = super().get_context_data(**kwargs)
    #     context['test'] = 'CBV'
    #     return context

# cofig/urls.py
path('cb/<int:pk>/', cb_views.BlogDetailView.as_view(), name = 'cb_blog_detail'), 


# 생성 페이지 (CreateView)

# views.py
# LoginRequiredMixin  @login_required 와 동일한 기능
class BlogCreateView(LoginRequiredMixin,CreateView):
    model = Blog
    template_name = 'blog_create.html'
    # form 설정
    # fields = '__all__'
    fields = ('category','title','content')
    # success_url = reverse('cb_blog_list') # 서로가 서로를 임포트하는 서큘러 임포트가 발생
    # success_url = reverse_lazy('cb_blog_list')  # create 성공시 동작
    # success_url = reverse_lazy('cb_blog_detail', kwargs={'pk':object.pk})  # 오류남.

    # 작성자 생성 후 save()동작
    def form_valid(self, form):
        # blog = form.save(commit=False)
        # blog.object = form.save(commit=False)
        # blog.object.author = self.request.user
        # blog.object.save()
        # self.object = blog
        self.object = form.save(commit=False)
        self.object.author = self.request.user
        self.object.save()
        return HttpResponseRedirect(self.get_success_url())

    # create 성공시 동작
    def get_success_url(self):
        return reverse_lazy('cb_blog_detail', kwargs={'pk':self.object.pk})

# cofig/urls.py
path('cb/create/', cb_views.BlogCreateView.as_view(), name = 'cb_blog_create'),


# 수정 (UpdateView)

# views.py
class BlogUpdateView(LoginRequiredMixin, UpdateView):
    model = Blog
    template_name = 'blog_update.html'
    fields = ('category','title','content')

    # 로그인 유저와 작성자가 같을 때만 수정 가능하게 처리
    # 1
    def get_queryset(self):
        queryset = super().get_queryset()
        return queryset.filter(author=self.request.user)
    # 2
    # def get_object(self, queryset=None):
    #     self.object = super().get_object(queryset)
    #     if self.object.author != self.request.user:
    #         raise Http404
    #     return self.object

    # update 성공 시 동작
    # def get_success_url(self):
        # return reverse_lazy('cb_blog_detail', kwargs={'pk':self.object.pk})
    # get_success_url이 없으면 model의 get_absolute_url찾아서 처리

# models.py
# get_absolute_url은 보통 detail페이지
def get_absolute_url(self):
    return reverse('cb_blog_detail', kwargs={'pk':self.pk})

# cofig/urls.py
path('cb/<int:pk>/update/', cb_views.BlogUpdateView.as_view(), name = 'cb_blog_update'),


# 삭제 (DeleteView)

# views.py
class BlogDeleteView(LoginRequiredMixin, DeleteView):
    model = Blog

    # 로그인 유저와 작성자가 같을 때만 삭제 가능하게 처리
    def get_queryset(self):
        queryset = super().get_queryset()
        return queryset.filter(author=self.request.user)

    # delete 성공 시 동작
    def get_success_url(self):
        return reverse_lazy('blog_list')

# cofig/urls.py
path('<int:pk>/delete/', cb_views.BlogDeleteView.as_view(), name = 'blog_delete'),   # login 기능


옵션 + 엔터 : 해당 이름으로 임포트 가능한 목록 보여줌


-----------------------
# include()
-----------------------

# blog/urls.py
from django.urls import path
from blog import cb_views

app_name = 'blog'

urlpatterns = [
    # CBV blog
    path('', cb_views.BlogListView.as_view(), name = 'list'),
    path('<int:pk>/', cb_views.BlogDetailView.as_view(), name = 'detail'),
    path('create/', cb_views.BlogCreateView.as_view(), name = 'create'),
    path('<int:pk>/update/', cb_views.BlogUpdateView.as_view(), name = 'update'),
    path('<int:pk>/delete/', cb_views.BlogDeleteView.as_view(), name = 'delete'),
]

# cofig/urls.py
path('fb/', include('blog.fbv_urls')),  # 경로에 fb/추가됨.
path('blog/', include('blog.urls')),  # blog/

# url불러올 때 app_name:name
# html에서 불러오기
{% url 'blog:detail' blog.pk %}
{% url 'blog:list' %}

# python에서 불러오기
reverse_lazy('blog:list')
redirect(reverse('blog:list'))


-----------------
# admin 권한 동작
-----------------

# 관리자 권한 여부 확인
request.user.is_superuser
request.user.is_staff


# 관리자 권한 있을 시 모두 허용

def get_queryset(self):
    queryset = super().get_queryset()
    if self.request.user.is_superuser:
        return queryset
    return queryset.filter(author=self.request.user)

def get_queryset(self):
    queryset = super().get_queryset()
    # superuser가 아니면 로그인 유저와 글쓴이가 동일한 데이터만 반환
    # 조건문이 많아지면 not으로 쓰는걸 더 추천한다고 함.
    if not self.request.user.is_superuser:
        return queryset.filter(author=self.request.user)
    return queryset


# 작성자와 로그인 유저가 같거나 관리자 권한이 있으면 접근가능
{% if request.user == blog.author or request.user.is_superuser %}


# default='free' 추가
category = models.CharField('카테고리', max_length=20, choices=CATEGORY_CHOICES, default='free')

python3 manage.py makemigrations
python3 manage.py migrate
python3 manage.py shell_plus
# blog.objects.filter(category__isnull=true) # Null인 데이터 확인
# Blog.objects.filter(category='')  # 비어있는 데이터 확인
# Blog.objects.filter(category='').update(category='free')


# js, css파일 적용하기 위해 static폴더 생성 및 설정
# config/settings.py
STATIC_URL = 'static/'
STATIC_DIR = BASE_DIR / 'static'

STATICFILES_DIRS = [
    STATIC_DIR,
]

# STATIC_ROOT - 배포환경에서 static파일들을 한곳에 모아서 관리할 수 있음.
STATIC_ROOT = BASE_DIR / '.static_root'


# static폴더에 다운받은 부트스트랩 js, css파일 복사

# base.html
{% load static %} # 최상단에 배치
<link href="{% static 'css/bootstrap.css' %}" rel="stylesheet">
<script src="{% static 'js/bootstrap.bundle.js' %}"></script>


# context 수정
def get_context_data(self, **kwargs):
    context = super().get_context_data(**kwargs)
    context['sub_title'] = '수정'
    context['btn_name'] = '수정'
    return context

# **kwargs, *args 구조
# **kwargs 딕셔너리 형태
# *args 리스트 형태
#     test_dict = {
#         'a' : 1,
#         'b' : 2,
#         'c' : 3,
#     }
#     self.test(a=test_dict['a'], b=test_dict['b'], c=test_dict['c'])
#     self.test(**test_dict)
#     test_list = [1,2,3]
#     self.test(test_list[0], test_list[1], test_list[2])
#     self.test(*test_list)
#     return context
# def test(self, a, b, c):
#     return

# 장고 템플릿 include 기능
{% block js %}
    {% include 'form_js.html' %}
{% endblock %}

# form_js.html
<script>
    document.querySelectorAll('select, input, textarea').forEach(function(ele) {
        ele.classList.add('form-control')
    });
</script>


# TimestampModel에서 created_at, updated_at을 상속받아서 사용
# utils/models.py
from django.db import models
class TimestampModel(models.Model):
    created_at = models.DateTimeField('작성일자', auto_now_add=True)
    updated_at = models.DateTimeField('수정일자', auto_now_add=True)

    class Meta:
        abstract = True

# blog/admin.py
# TabularInline 표로 만들어서 inline으로 넣어주는 기능
class CommentInline(admin.TabularInline):
    model = Comment
    fields = ['content', 'author']
    extra = 1  # 기본 3개

@admin.register(Blog)
class BlogAdmin(admin.ModelAdmin):
    inlines = [
        CommentInline,
    ]


-------------------------
# 댓글 기능
-------------------------

# 댓글 모델 생성

blog/models.py

class Comment(TimestampModel):
    # TimestampModel에서 created_at, updated_at을 상속받음
    # created_at = models.DateTimeField('작성일자', auto_now_add=True)
    # updated_at = models.DateTimeField('수정일자', auto_now_add=True)
    blog = models.ForeignKey(Blog, on_delete=models.CASCADE)
    content = models.CharField('본문', max_length=255)
    author = models.ForeignKey(User, on_delete=models.CASCADE)

    def __stf__(self):
        return f'{self.blog.title} 댓글'

    class Meta:
        verbose_name = '댓글'
        verbose_name_plural = '댓글 목록'
        ordering = ('-created_at', '-id',) # 댓글 최신순으로 정렬


# 어드민의 블로그 페이지에서도 댓글 수정 가능하게 설정

# blog/admin.py

admin.site.register(Comment)

# TabularInline 표로 만들어서 inline으로 넣어주는 기능
class CommentInline(admin.TabularInline):
    model = Comment
    fields = ['content', 'author']
    extra = 1  # 기본 3개

@admin.register(Blog)
class BlogAdmin(admin.ModelAdmin):
    inlines = [
        CommentInline,
    ]


# 댓글 생성 기능 (CreateView사용)
-----------------------------

# 방법 1
# BlogDetailView에서 post요청으로 댓글을 처리하는 기능
# blog/cb_views.py DetailView에 추가
class BlogDetailView(DetailView):
    queryset = Blog.objects.all().prefetch_related('comment_set', 'comment_set__author')

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['comment_form'] = CommentForm()
        return context

    # post요청시
    def post(self, *args, **kwargs):
        comment_form = CommentForm(self.request.POST)

        if not comment_form.is_valid():
            self.object = self.get_object()
            context = self.get_context_data(object=self.object)
            context['comment_form'] = comment_form
            return self.render_to_response(context)

        if not self.request.user.is_authenticated:
            raise Http404

        comment = comment_form.save(commit=False)
        # comment.blog = self.get_object() # 블로그 정보 저장
        comment.blog_id = self.kwargs['pk']  # blog_id 직접 설정
        comment.author = self.request.user
        comment.save()

        return HttpResponseRedirect( reverse_lazy('blog:detail', kwargs={'pk':self.kwargs['pk']}))


# 폼 정의

# blog/forms.py

class CommentForm(forms.ModelForm):
    class Meta:
        model = Comment
        fields = ('content',)
        # 특정 필드에 TextInput 삽입
        widgets = {
            'content': forms.TextInput(attrs={'class':'form-control'}) # content필드에 textinput 삽입
        }
        # Comment 모델이 가지고있는 verbose_name 쓰지 않고 따로 지정
        labels = {
            'content': '댓글'
        }

# blog_detail에서 댓글 생성하는 post요청 추가
# blog_detail.html

{% if request.user.is_authenticated %}
    <form method="post" >
        {% csrf_token %}
        {{ comment_form.as_p }}
        <div class="text-end">
            <button class="btn btn-primary opacity-50">댓글작성</button>
        </div>
    </form>
{% endif %}


# 방법 2
# blog/cb_views.py
# /comment/create/<int:blog_pk>/
class CommentCreateView(LoginRequiredMixin, CreateView):
    model = Comment
    form_class = CommentForm

    def get(self, *args, **kwargs):
        raise Http404

    def form_valid(self, form):
        blog = self.get_blog()
        self.object = form.save(commit=False)
        self.object.author = self.request.user
        self.object.blog = blog
        self.object.save()
        return HttpResponseRedirect(reverse('blog:detail', kwargs={'pk':blog.pk} ))

    def get_blog(self):
        pk = self.kwargs['blog_pk']
        blog = get_object_or_404(Blog, pk=pk)
        return blog


# blog/urls.py
path('comment/create/<int:blog_pk>/', cb_views.CommentCreateView.as_view(), name = 'comment-create'),

# action에 요청을 처리할 url설정
    <form method="post" action="{% url 'blog:comment-create' blog.pk %}">


------------------
# 댓글 조회
------------------

Django에서는 ForeignKey(외래 키) 관계가 설정되면, 역참조(Reverse Lookup)를 위한 관련 매니저가 자동으로 생성됩니다.
즉, Comment 모델이 Blog 모델을 참조하고 있다면, Django는 자동으로 blog.comment_set이라는 매니저를 제공하여 해당 Blog 객체에 연결된 모든 Comment를 가져올 수 있도록 합니다.
{% for comment in blog.comment_set.all %}
    <div>
        {{ comment.content }}
        <p class="text-end">
            <small>{{ comment.created_at | date:'Y-m-d H:i' }} | {{ comment.author.username }}</small>
        </p>
    </div>
{% endfor %}

# comment_set 때문에 쿼리가 두번 실행되기 때문에
# 블로그 데이터를 불러올 때 댓글도 같이 불러와서 쿼리가 한번반 실행되도록 수정
# 쿼리셋에 comment_set을 조인 시킴

# blog/models.py
#class BlogDetailView(DetailView)에 추가
queryset = Blog.objects.all().prefetch_related('comment_set', 'comment_set__author')


----------------------------
# 댓글 페이지 네이션 기능 추가
----------------------------

댓글 여러개 생성
comment_list = Comment.objects.filter(blog_id=144)
new_list = []

for i in range(10):
    for comment in comment_list:
        comment.id = None
        new_list.append(comment)

Comment.objects.bulk_create(new_list)

# 기존 디테일뷰
# class BlogDetailView(DetailView):
#     model = Blog
#     글을 불러올때 댓글도 같이 불러오게 설정. 설정하지 않으면 요청을 두 번하게됨.
#     queryset = Blog.objects.all().prefetch_related('comment_set', 'comment_set__author')
#     Django에서는 ForeignKey(외래 키) 관계가 설정되면, 역참조(Reverse Lookup)를 위한 관련 매니저가 자동으로 생성됩니다.
#     즉, Comment 모델이 Blog 모델을 참조하고 있다면, Django는 자동으로 blog.comment_set이라는 매니저를 제공하여 해당 Blog 객체에 연결된 모든 Comment를 가져올 수 있도록 합니다.

# 상세 페이지에서 댓글 페이지 기능을 사용하기 위해 리스트뷰를 사용
class BlogDetailView(ListView):  # 댓글
    model = Comment
    template_name = 'blog_detail.html'
    paginate_by = 10
    # pk_url_kwarg = 'blog_id'  # url에서 pk말고 다른 이름으로 id값 가져올 시 설정

    # 블로그 정보 불러옴.
    def get(self, request, *args, **kwargs):
        self.object = get_object_or_404(Blog, pk=kwargs.get('blog_pk'))
        return super().get(request, *args, **kwargs)

    def get_queryset(self):
        return self.model.objects.filter(blog=self.object).prefetch_related('author')

    # context에 블로그 추가
    # 사용자 지정 context
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['comment_form'] = CommentForm()
        context['blog'] = self.object
        return context

# 페이지 기능을 include를 사용해 재사용하기 위해 pagination.html 추가
# 링크에 fragment 추가

# pagination.html

<div class="text-align-center d-flex justify-content-center">
    <ul class="pagination">
        {% if page_obj.has_previous %}  {# 이전 페이지 존재시 #}
            <li class="page-item">
                <a class="page-link" href="?page=1{% if request.GET.q %}&q={{ request.GET.q }}{% endif %}{% if fragment %}#{{ fragment }}{% endif %}">&laquo; 첫번째</a>
            </li>
            <li class="page-item">
                <a class="page-link" href="?page={{ page_obj.previous_page_number }}{% if request.GET.q %}&q={{ request.GET.q }}{% endif %}{% if fragment %}#{{ fragment }}{% endif %}">이전</a></li>
        {% endif %}

        {# 총 페이지 중에 현재 몇 페이지인지 표시 #}
        {# <span> Page {{ page_obj.number }} of {{ page_obj.paginator.num_pages }} </span> #}

        {# 현재페이지 -2 > 1 이면 ... #}
        {% if page_obj.number|add:-2 > 1 %}
            <il class="page-item">
                <a class="page-link" href="?page={{ page_obj.number|add:-3 }}{% if request.GET.q %}&q={{ request.GET.q }}{% endif %}{% if fragment %}#{{ fragment }}{% endif %}">&hellip;</a>
            </il>
        {% endif %}
        {% for i in page_obj.paginator.page_range %}
            {% if page_obj.number == i %}
                <il class="page-item">
                    <a class="page-link active" href="?page={{ i }}{% if request.GET.q %}&q={{ request.GET.q }}{% endif %}{% if fragment %}#{{ fragment }}{% endif %}">{{ i }}</a>
                </il>
            {# 현재페이지 - 2 <= 현재페이지 <= 현재페이지 + 2 #}
            {% elif page_obj.number|add:-2 <= i and i <= page_obj.number|add:2 %}
                <li class="page-item">
                    <a class="page-link" href="?page={{ i }}{% if request.GET.q %}&q={{ request.GET.q }}{% endif %}{% if fragment %}#{{ fragment }}{% endif %}">{{ i }}</a>
                </li>
            {% endif %}
        {% endfor %}
        {# 최대페이지 > 현재페이지 + 2 이면 ... #}
        {% if page_obj.paginator.num_pages > page_obj.number|add:2 %}
            <li class="page-item">
                <a class="page-link" href="?page={{ page_obj.number|add:3 }}{% if request.GET.q %}&q={{ request.GET.q }}{% endif %}{% if fragment %}#{{ fragment }}{% endif %}">&hellip;</a>
            </li>
        {% endif %}

        {% if page_obj.has_next %} {# 다음 페이지 존재시 #}
            <li class="page-item">
                <a class="page-link" href="?page={{ page_obj.next_page_number }}{% if request.GET.q %}&q={{ request.GET.q }}{% endif %}{% if fragment %}#{{ fragment }}{% endif %}">다음</a>
            </li>
            <li class="page-item">
                <a class="page-link" href="?page={{ page_obj.paginator.num_pages }}{% if request.GET.q %}&q={{ request.GET.q }}{% endif %}{% if fragment %}#{{ fragment }}{% endif %}">마지막 &raquo;</a>
            </li>
        {% endif %}
    </ul>
</div>

# include기능을 사용해 pagination.html을 불러옴
{%  include 'pagination.html' %}
{%  include 'pagination.html' with fragment='comment_wrapper' %}



---------------------------
서머노트 (summernote)
글쓰기 기능과 각종 이미지 첨부, 파일첨부 등 각종 기능을 쉽게 사용할 수 있게 해주는 패키지
https://summernote.org/
https://github.com/lqez/django-summernote


# 서머 노트를 받고 마이그레이트

poetry add django-summernote
python3 manage.py migrate 


# 셋팅 설정

# settings.py

THIRD_PARTY_APPS = [
    'django_summernote',
]
#media
# 유저가 올리는 각종 파일들을 저장하는 경로
MEDIA_URL = 'media/'
MEDIA_ROOT = BASE_DIR / 'media'


# admin.py

@admin.register(Blog)
# class BlogAdmin(admin.ModelAdmin):
class BlogAdmin(SummernoteModelAdmin):
    summernote_fields = ['content',]
    inlines = [
        CommentInline,
    ]


#config/urls.py

# config.settings 보단 django.conf의 settings가 나음.
# 현재 장고 실행환경에서 셋팅을 불러옴.  배포환경에서는 경로가 달라질 수 있기 때문에 이렇게함.
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)  # django.conf.urls.static
    
urlpatterns = [
    path('summernote/', include('django_summernote.urls')),
]


# 랜덤 이미지 써머노트에 붙여넣기

랜덤 이미지 사이트
https://picsum.photos/
https://picsum.photos/200/300

{{ blog.content | safe }}  <!-- 써머노트 쓸 때 html코드를 사용할 수 있게 설정 -->



# 폼 설정
# forms.py
class BlogForm(forms.ModelForm):
    class Meta:
        model = Blog
        # fields = '__all__'  # 전체 적용
        fields = ('category','title','content',)  # 원하는 것만 적용
        widgets = {
            'content': SummernoteWidget()
        }

cv_views.py
blog_create, blog_update에 적용
form_class = BlogForm  # 써머노트 쓸 때 fields 대신 사용

서머노트 옵션 설정
깃허브에 옵션 복사

# settings.py
맨아래 설정 
# summernote
SUMMERNOTE_CONFIG = {
    # Using SummernoteWidget - iframe mode, default

    # Or, you can set it to `False` to use SummernoteInplaceWidget by default - no iframe mode
    # In this case, you have to load Bootstrap/jQuery sources and dependencies manually.
    # Use this when you're already using Bootstrap/jQuery based themes.
    'iframe': False,

    # You can put custom Summernote settings
    'summernote': {
        # As an example, using Summernote Air-mode
        'airMode': False,

        # Change editor size
        'width': '100%',
        'height': '480',

        # Use proper language setting automatically (default)

        # Toolbar customization
        # https://summernote.org/deep-dive/#custom-toolbar-popover
        'toolbar': [
            ['style', ['style']],
            ['font', ['bold', 'underline', 'clear']],
            ['fontname', ['fontname']],
            ['color', ['color']],
            ['para', ['ul', 'ol', 'paragraph']],
            ['table', ['table']],
            ['insert', ['link', 'picture', 'video']],
            ['view', ['fullscreen', 'codeview', 'help']],  # 코드뷰 보기해서 코드 넣으면 실행됨.
        ],

        # Or, explicitly set language/locale for editor
        'lang': 'ko-KR',

        # You can also add custom settings for external plugins
        'print': {
            'stylesheetUrl': '/some_static_folder/printable.css',
        },
        'codemirror': {
            'mode': 'htmlmixed',
            'lineNumbers': 'true',
            # You have to include theme file in 'css' or 'css_for_inplace' before using it.
            'theme': 'monokai',
        },
    },

    # Require users to be authenticated for uploading attachments.
    'attachment_require_authentication': True,

    # You can completely disable the attachment feature.
    'disable_attachment': False,

    # Set to `False` to return attachment paths in relative URIs.
    'attachment_absolute_uri': True,

    # test_func in summernote upload view. (Allow upload images only when user passes the test)
    # https://docs.djangoproject.com/en/2.2/topics/auth/default/#django.contrib.auth.mixins.UserPassesTestMixin

    # # You can add custom css/js for SummernoteWidget.
    # 'css': (
    # ),
    # 'js': (
    # ),
    #
    # # You can also add custom css/js for SummernoteInplaceWidget.
    # # !!! Be sure to put {{ form.media }} in template before initiate summernote.
    # 'css_for_inplace': (
    # ),
    # 'js_for_inplace': (
    # ),
    #
    # # Codemirror as codeview
    # # If any codemirror settings are defined, it will include codemirror files automatically.
    # 'css': (
    #     '//cdnjs.cloudflare.com/ajax/libs/codemirror/5.29.0/theme/monokai.min.css',
    # ),
    #
    # # Lazy initialization
    # # If you want to initialize summernote at the bottom of page, set this as True
    # # and call `initSummernote()` on your page.
    # 'lazy': True,
    #
    # # To use external plugins,
    # # Include them within `css` and `js`.
    # 'js': {
    #     '/some_static_folder/summernote-ext-print.js',
    #     '//somewhere_in_internet/summernote-plugin-name.js',
    # },
}

# 계산기 앱
# 옵션 설정 안하면 이와 같은 스크립트 사용가능
https://www.geeksforgeeks.org/javascript-calculator/


image = models.ImageField('이미지', null=True, blank=True, upload_to='blog/%Y/%m/%d')
# 2024/4/23일
# blog/2024/4/23/이미지파일.jpg
# ImageField, FieldField와 같은데 이미지만 업로드하게 되어있다.
# varchar => 경로만 저장을 함

이미지 필드를 사용하기 위해 pillow를 설치
poetry add pillow

필드 추가후 마이그레이션
python3 manage.py makemigrations
python3 manage.py migrate


# 데이터 처리
# CBV에서 데이터 처리는 def from_falid(self, form):
# FBV에서 데이터 처리는 if is_valid():
def form_valid(self, form):
    print(form.cleaned_data)
    return super().form_valid(form)

장고는 저장할 때 파일 이름이 난수를 사용해 이름을 변경해 저장한다.

# form.py
폼 필드에 추가
fields = ('category','title', 'image', 'content')  # 원하는 것만 적용, 순서대로 적용됨.

# form.html
# 타입설정
# multipart 여러개 업로드 가능하게 설정
<form method="POST" enctype="multipart/form-data">

# 이미지 보이게 설정하기

이미지가 제대로 처리될 수 있게 선언

# views.py
# def blog_update(request, pk):
#       form = BlogForm(request.POST or None, request.FILES or None, instance=blog)  # instance 폼의 항목에 맞게 blog에서 데이터를 불러옴
# request FILES of None
# form = BlogForm(None, None, instance=blog) # 순서대로 매개변수

# blog_list.html, blog_detail.html
{% if blog.image %}
    <img src="{{ blog.image.url }}" alt="" class="col-2">
{% endif %}

--------------------------
# 썸네일 이미지
--------------------------
원본을 바로 가져오면 서버가 느려지기 때문에 썸네일을 가져오도록 처리

무료 이미지 사이트
pexels

# models.py
thumbnail = models.ImageField('썸네일', null=True, blank=True, upload_to="blog/%Y/%m/%d/thumbnail")

from PIL import Image

# models.py
    # 썸네일 이미지 가져오는 함수
    def get_thumbnail_image_url(self):
        if self.thumbnail:
            return self.thumbnail.url
        elif self.image:
            return self.image.url
        return None
    
    # save()함수 override
    def save(self, *args, **kwargs): # *args 리스트 **kwargs 키워드
        if not self.image:
            return super().save(*args, **kwargs)

        image = Image.open(self.image)
        image.thumbnail((300, 300))
        image_path = Path(self.image.name)
        thumbnail_name = image_path.stem # /blog/2024/4/23/database.png => 파일 이름만 불러옴
        thumbnail_extension = image_path.suffix.lower() # 파일의 확장자를 가져옴 # 소문자로 바꿔서 처리
        thumbnail_filename = f'{thumbnail_name}_thumb{thumbnail_extension}' # 이름_thumb.확장자

        if thumbnail_extension in ['.jpg','jpeg']:
            file_type = 'JPEG'  # jpg일때 처리가 안되서 바꿔서 처리
        elif thumbnail_extension == '.gif':
            file_type = 'GIF'
        elif thumbnail_extension == '.png':
            file_type = 'PNG'
        else:
            return super().save(*args, **kwargs)

        temp_thumb = BytesIO()
        image.save(temp_thumb, file_type)
        temp_thumb.seek(0)
        self.thumbnail.save(thumbnail_filename, temp_thumb, save=False)
        temp_thumb.close()
        return super().save(*args, **kwargs)
        

--------
텍스트
--------

- CharField 짧은글 / 길이 제한 o
- TextField 길글 / 길이 제한 x
- URLField: URL 저장 / CharField  / url validation 가능
- SlugField : Slug 저장 / CharField  url주소에 '-' 연결된 것 / 잘 안씀
- UUIDField : UUID 저장/ 잘 안씀

--------
파일
--------

- EmailField :  이메일을 저장
- FileField : 파일 저장
- ImamgeField : 이미지 저장 / 저장할 파일 선택할 때 이미지만 활성화됨



--------
숫자
--------

IntegerField : 숫자 필드
PositiveIntegerField: 양수만 가능한
BigIntegerField : 큰 숫자 필드
PositiveBigIntegerField : 양수만 가능한 큰 숫자필드
DecimalField : Decimal 저장 / 부동소수점 오차가 없는 필드
FloatField : Float 저장


Float => 부동 소수점
- 조금 부정확하지만 큰 수를 표현

Decimal => 고정 소수점
- 정환하지만 상대적으로 작은 수


--------
날짜 시간
--------
DateTimeField : 날짜 및 시간을 저장
DateField : 날짜만 저장
TimeField : 시간만 저장


--------
연결
--------

 ForeignKey : 1:N 관계 / 자신이 N
 ManyToManyField : N:N관계
 OneToOneField : 1:1 관계

--------
 기타
--------
 JSONField : JSON 형태의 데이터를 저장
 

django fields 검색


-----------------
DB 설계를 잘하는 법
-----------------
제일 중요한 것은 중복된 데이터를 많이 적지 않습니다.
Join을 과하게 많이 하지 않습니다.
