Django (장고)

1. ORM(Object relational Mapping) -> DB구조와 쿼리를 할 수 있는 기능
2. Authentication & Authorization -> 인증 허가(로그인 관련 기능)
3. Admin Interface -> 관리자 인터페이스 자동 생성 지원
4. internationalization -> 국제화, 번역 기능
5. URL Routing -> URL을 이용한 페이지 처리
6. Template Engine

MVT 구조 (MVC구조 이전의 구조)

Model : DB관련 기능 수행
View : 실질적인 메인 알고리즘
Template : 유저들에게 보여주는 화면단

장점

개발 속도가 빠름
코드 재사용 및 모듈화: 유연
안전한 웹 애플리케이션 구축: 보안


단점
잘 쓰려면 숙련 및 개념 탑재 필요
Django적인 개발 문법이 필요.
익혀야하는 개념들이 조금 복잡함.

쓰는 이유?
Flask나 FastAPI는 여러개 패키지를 가져다 써야하는데 반해, 모두 준비가 되어 있음
개발 시간을 줄여주는 관리자 페이지의 마법!!
개발 시간 및 코드를 줄여주는 모듈화의 마법?
획일화된 구조로 누가 코드를 봐도 적응 시간이 빠름
수 많은 패키지와 잘 구축된 커뮤니티

브라우저 -> Web Server -> urls.py -> Views.py(처리) -> Model.py -> DB
DB -> Model.py -> Views.py -> Template -> Views.py -> Web Server -> 브라우저

--------------
장고 시작하기
--------------

 # oz라는 이름으로 가상환경 생성
 pyenv virtualenv 3.12.1 oz
 
 # 가상환경 실행
 pyenv local oz
 
 # poetry 설치
 brew install poetry
 
 # poetry 초기화
 # Package name은 oz_bookmark로 설정
 # Author에만 n을 입력하고 나머지는 전부 Enter를 눌러 진행합니다.
 poetry init

이것만 하고 나머진 엔터로 스킵해도 무관
Package name [bookmark]:  이름입력
Version [0.1.0]:  엔터
Description []:  엔터
Author [LucasKim4321 <xowls0131@naver.com>, n to skip]:  n입력

poetry add django 최신버전 설치
poetry add django==5.0.3 원하는 버전 설치

서버 실행
python3 manage.py runserver


urls.py 기본 구조

def index(request):
    return HttpResponse('<h1>hello2</h1>')

urlpatterns = [
    path('admin/', admin.site.urls), # 기본적으로 만들어져있는 admin페이지
    path('url경로', 사용할 함수),
    path('', index),
    path('book_list/<int:num>/', book),
    path('language/<str:lang>/', language),  # <str>을 쓰면 모든 문자열이 인식되서 모든 경로에 영향을 끼침
]

앱(app) 생성
python3 manage.py startapp 앱이름
python3 manage.py startapp bookmark
프로젝트 폴더에 설정한 이름의 앱폴더가 생성됨

앱 하위 요소
models.py DB관련된 테이블, 컬런 관리
views.py 메인 알고리즘
tests.py 테스트 코드를
app.py 장고 앱 설정
admin.py 관리자 기능 설정
__init__.py 파이선 패키지 만드는 파일
migrations models.py 변경사항 기록

앱 등록
INSTALLED_APPS = [
    '앱이름',
]

DB Browser for SQLite 설치
open database
프로젝트 폴더/db.sqlite3

# 앱에 필요한 테이블 admin, auth, contenttypes, sessions
# 마이그레이션하면 오류 내용 없어짐.

# 마이그레이션
# 마이그레이션 파일을 바탕으로 DB에 적용(마이그레이션)하는 과정
python3 manage.py migrate

# 마이그레이션 생성
# 마이그레이션 할 내용을 작성하는 과정
python3 manage.py makemigrations
migrations/migration.py 파일을 생성


admin페이지 관리자 계정 생성
python3 manage.py createsuperuser

장고 페이지 언어 설정
setting.py
LANGUAGE_CODE = 'ko-KR' # 모든 장고 페이지가 한글로 바뀜


-----------------------
    Django ORM
-----------------------

objects => 모델 매니저/ 쿼리를 할 수 있게 해줌

모델의 모든 데이터 가져오기  (SELECT * FROM 테이블명)
Bookmark = 모델명.objects.all()  # 리스트

조건을 만족하는 모델 하나의 데이터 가져오기 (SELECT * FROM 모델명 WHERE id=id LIMIT 1)
Bookmark = 모델명.objects.get(id=id)  # 단일데이터
Bookmark = 모델명.objects.get(pk=pk)  # 단일데이터

조건을 만족하는 모든 모델 데이터 가져오기 (SELECT * FROM 모델명 WHERE id=id)
Bookmark = 모델명.objects.filter(pk=pk)  # 리스트

조건을 만족하는 모든 모델 데이터 가져오기 (SELECT * FROM 모델명 WHERE created_at >= now)
gte : greater than or equal  lte : less than or equal
not = datetime.now()
Bookmark = 모델명.objects.filter(created_at__gte = now)  # 리스트

SELECT * FROM bookmark WHERE name='네이버'
Bookmark = 모델명.objects.filter(name = '네이버')

SELECT * FROM bookmark WHERE name LIKE '%네이버%'
Bookmark = 모델명.objects.filter(name__icontains = '네이버')

# 첫번째 요소 반환
모델명.objects.first()

# 마지막 요소 반환
모델명.objects.last()

# 특정 글자로 시작하는 요소 반환
모델명.objects.filter(name__startswith='네')

# 특정 글자로 끝나는 요소 반환
모델명.objects.filter(name__endswith='버')

# 네이버 또는 다음을 포함하는 요소 반환
모델명.objects.filter(name__in=['네이버','다음'])

# AND 조건
모델명.objects.filter(name='네이버', url__startswith='https://naver')

# 데이터 추가 1
모델명.objects.create(name='야후', url='https://yahoo.com')

# 데이터 추가 2
bookmark = Bookmark(name='야후2', url='https://yahoo.com')  # save()하기전엔 데이터베이스에 반영되지 않음
bookmark.save()
bookmark.id  # save()전엔 id값이 없었는데 save()후 id값이 생김

마지막 출력의 첫번째가 b에 저장됨.
b = _.first()

# id값을 없앰
b.id = None

# save()하면 id값이 없어서 새로운 객체로 인식해서 새로 저장됨.
b.save()

# 특정 데이터 수정
Bookmark.objects.filter(url__icontains='naver.com').update(name='naver')

# 한번에 데이터를 생성해서 쿼리문을 사용하는 횟수를 줄여 부담을 줄임.
# bookmarks = [Bookmark(name=f'테스트 구글 {i}', url='https://google.com') for i in range(10)]
# Bookmark.objects.bulk_create(bookmarks)

Bookmark.objects.bulk_update()


가져오기 실패시 404오류 반환
# 1
try:
    bookmark = Bookmark.objects.get(pk=pk)
except:
    raise Http404
# 2
bookmark = get_object_or_404(Bookmark, pk=pk)


장고 파이선 셀 사용
python3 manage.py shell

나가기
컨트롤 d 또는 exit()


poetry 사용
Poetry는 Python 패키지 및 가상환경을 효율적으로 관리할 수 있도록 도와주는 패키지 관리 도구입니다.
기존의 pip + virtualenv 조합보다 더 강력하고 간편한 방식으로 Python 프로젝트를 관리할 수 있습니다.

# poetry프로젝트 초기화
# pyproject.toml파일이 생성됨. pyproject.toml은 프로젝트의 의존성(패키지), Python 버전, 프로젝트 메타데이터 등을 관리하는 설정 파일입니다.
poetry init

# ipython을 Poetry 환경에 추가합니다.
# 대화형 Python 인터프리터로, python보다 향상된 기능을 제공합니다.
poetry add ipython

poetry add ipython 한 후 파이선 셀을 실행하면 환경이 달라짐
python3 manage.py shell

# Django 개발을 편리하게 만들어주는 확장 기능 모음입니다.
# 추가적인 관리 명령어(manage.py shell_plus 등)와 도구를 제공합니다.
poetry add django-extensions

settings.py
INSTALLED_APPS
'django_extensions', 추가

터미널에서 실행
python3 manage.py shell_plus

shell_plus에선 기본적으로 대부분이 ipmort되어 있음
Bookmark.objects.all() 이렇게 바로 import 안하고 바로 사용 가능


pycharm 명령어 설정
.zshrc에 명령어 등록
echo 'export PATH="/Applications/PyCharm.app/Contents/MacOS:$PATH"' >> ~/.zshrc에
터미널 재시작
source ~/.zshrc


---------------------
session & cookie
---------------------

구분       쿠키                                      세션
저장 위치   클라이언트                                  서버 (클라이언트에는 키만 저장하고 실제 데이터는 서버에 존재)
저장 형식   텍스트                                     Object형
종료 시점   쿠키 저장시 설정                             정확한 종료 시점을 알 수 없다
          (설정하지 않으면 브라우저 종료시)
자원       클라이언트 자원                              서버의 자원
용량 제한   한 도메인당 20개, 쿠키 하나당 4KB, 총 300개     서버가 허용하는 한 용량에 제한이 없음

# 쿠키(cookie)
# visit을 키값으로 쿠키를 가져오고 존재하지 않으면 0 있으면 +1
visits = int(request.COOKIES.get('visits', 0 )) + 1
response =  render(request, 'blog_list.html', context)
response.set_cookie('visits', visits)
return response

# 세션(session)
request.session['count'] = request.session.get('count', 0) +1
context = {
    'blogs': blogs,
    'count': request.session['count'],
}


장고 로그인 기능 구현

url설정
path('accounts/', include('django.contrib.auth.urls')), # include() 장고에 내장된 url사용

html에 설정 {# 장고로 로그인 기능 사용시 토큰 필요함 #}
{% csrf_token %} 

settings.py
# login 성공시 url 설정
LOGIN_REDIRECT_URL = '/'


요구 패키지 목록 생성
pip3 freeze > requirements.txt

패키지 목록 설치
pip install -r requirements.txt

패키지 목록을 최신버전으로 설치
pip install --upgrade -r requirements.txt


-----------------------
    관리자(admin)
-----------------------

특정 모델에 대한 admin기능 활성화
@admin.register(모델명)
class 클래스명(admin.ModelAdmin):
    pass

class Blog(models.Model):
    CATEGORY_CHOICES = (
        ('free','자유'),
        ('travel','여행'),
        ('cat','고양이'),
        ('dog','개'),
    )
    category = models.CharField('카테고리', max_length=20, choices=CATEGORY_CHOICES)  # 첫번째 매개변수 verbose_name(관리자 페이지에서 표시될 이름)
    title = models.CharField('제목', max_length=100)
    content = models.TextField('본문')
    created_at = models.DateTimeField('작성일자', auto_now_add=True)  # 생성시 자동으로 현재 시간 추가
    updated_at = models.DateTimeField('수정일자', auto_now_add=True)

    # 관리자 페이지에서 blog object 라고 표시되는 사항 변경
    def __str__(self):
        return f'[{self.get_category_display()}] {self.title[:10]}'

    class Meta: # 필수는 아니고 admin 등에서 사용 (없어도 무관)
        verbose_name = '블로그'  # verbose_name 따로 지정. 지정하지 않으면 Blog
        verbose_name_plural = '블로그 목록'  # verbose_name_plural 따로 지정. 지정하지 않으면 Blogs


-----------------------
    로그인(login)
-----------------------

# 장고에 내장된 login기능 사용
path('accounts/', include('django.contrib.auth.urls')), # include() 장고에 내장된 url사용

<form method="POST">
    {# 장고로 로그인 기능 사용시 토큰 필요함 #}
    {% csrf_token %}
    {{ form.as_p }}
    <button>로그인</button>
</form>

<form method="POST">
    {% csrf_token %}
    {{ form.as_p }}
    <button>회원가입</button>
</form>

{% if request.user.is_authenticated %}
<form action="{% url 'logout' %}" method="POST" style="display:inline">
    {% csrf_token %}
    <button>로그아웃</button>
</form>
{{ request.user.username }}
{% else %}
<a href="{% url 'signup' %}">회원가입</a>
<a href="{% url 'login' %}">로그인</a>
{% endif %}

# settings.py
# 장고 기본 로그인 기능 이용
# LOGIN_URL = '/accounts/login/'
# 따로 만든 로그인 기능 이용
LOGIN_URL = '/login/'

# login 성공시 url 설정
LOGIN_REDIRECT_URL = '/'
# logout 성공시 url 설정
LOGOUT_REDIRECT_URL = '/'

def sign_up(request):
    # username = request.POST['username'] # POST말고 다른 요청이 들어오면 브라우저에서 오류남.
    # username = request.POST.get('username') # 다른 요청이 들어오면 None이 발생하지만 오류가 나진 않음
    # print('username', username)

    # if request.method == 'POST':
    #     form = UserCreationForm(request.POST) # POST요청 데이터를 여러 처리과정(validation등)을 거친 후 form에 넣음
    #     if form.is_valid(): # 요구 조건 통과 여부 확인
    #         form.save() # 요구 조건이 맞으면 저장  # form에 내용을 DB에 반영하고 해당 데이터의 객체를 반환(리턴)함.
    #         return redirect('/accounts/login/')
    # else:
    #     form = UserCreationForm() # 장고에서 기본적으로 제공해주는 회원가입 폼

    # 이렇게 하면 조건문 안써도 됨.
    form = UserCreationForm(request.POST or None)
    if form.is_valid(): # 요구 조건 통과 여부 확인
        form.save() # 요구 조건이 맞으면 저장
        return redirect(settings.LOGIN_URL)

    context = {
        'form':form,
    }
    return render(request, 'registration/signup.html', context)

# 사용자 지정 로그인
def login(request):
    form = AuthenticationForm(request, request.POST or None)

    if form.is_valid(): # 요구 조건 통과 여부 확인
        django_login(request, form.get_user())  # 로그인을 시도함
        return redirect(reverse('blog_list'))  # html의 {% url 'blog_list' %} 와 동일

    context = {
        'form':form
    }
    return render(request, 'registration/login.html', context)

# 외례키 컬럼 추가
class Blog(models.Model):
    author = models.ForeignKey(User, on_delete=models.CASCADE)  # author_id
    # models.CASCATE => 같이 삭제 => 유저 삭제시 같이 블로그도 같이 삭제
    # models.PROTECT => 삭제가 불가능함 => 유저를 삭제하려고 할 때 블로그가 있으면 유저 삭제가 불가능 (기본값)
    # models.SET_NULL => 널 값을 넣음 => 유저 삭제시 블로그의 author가 Null이 됨.

    # 기존에 없던 author를 외례키로 추가하면 기존 블로그의 author값이 없어서 마이그레이션 할 때 에러남
    # python3 manage.py makemigrations 하면 기존 블로그 데이터에 기본값을 줄건지 물어봄.
    # 1번 기본값 주기 선택 후 기존 데이터의 초기값으로 주어질 id값 선택 하면 정상적으로 마이그레이션 됨.

html에서 외례키 author 불러오는 방법
{{ blog.author.username }}


# extends 기능 사용
# base가 되는 html문서 안에 외부 html문서를 내용으로 채우는 방식
# base.html
<body>
    <div>
        <h1>base title</h1>
    </div>
    {%  block content %}
    {% endblock %}
</body>

# login.html
{% extends 'base.html' %}
{% block content %}
    <form method="POST">
        {# 장고로 로그인 기능 사용시 토큰 필요함 #}
        {% csrf_token %}
        {{ form.as_p }}
        <button>로그인</button>
    </form>
{% endblock %}


# order_by('정렬 기준 값') 오름차순(ASC)으로 정렬.  값에 '-'를 붙이면 내림차순(DESC)정렬
blogs = Blog.objects.all().order_by('-created_at')


# 게시글 생성 기능 구현
@login_required # settings.py에 설정된 LOGIN_URL로 리다이렉트
def blog_create(request):
    # 로그인되어 있지 않으면 로그인화면으로 리다이렉트
    # if not request.user.is_authenticated:
    #     return redirect(reverse('login'))
    
    form = BlogForm(request.POST or None)
    if form.is_valid():
        # form.save() : form에 내용을 DB에 반영하고 해당 데이터의 객체를 반환(리턴)함.
        blog = form.save(commit=False)  # DB에 반영하지 않고 객체만 반환함.
        blog.author = request.user  # 작성자에 로그인된 유저를 넣음
        blog.save()  # DB에 반영
        return redirect(reverse('blog_detail', kwargs={'pk':blog.pk}))

    context = {
        'form':form,
    }

    return render(request, 'blog_create.html', context)

# 사용자 지정 폼 정의
from django import forms
from blog.models import Blog

class BlogForm(forms.ModelForm):
    class Meta:
        model = Blog
        # fields = '__all__'  # 전체 적용
        fields = ('title','content')  # 원하는 것만 적용

# blog_create.html
{% extends 'base.html' %}
{% block content %}
<form method="POST">
    <h1>블로그 작성</h1>
    {% csrf_token %}
    {{ form.as_p }}
    <button>생성</button>
</form>
{% endblock %}


# 게시글 수정 기능 구현
@login_required
def blog_update(request, pk):
    # blog = get_object_or_404(Blog, pk=pk)
    # if request.user != blog.author:
    #     raise Http404
    blog = get_object_or_404(Blog, pk=pk, author=request.user) # pk와 author가 일치하는 데이터만 가져옴

    form = BlogForm(request.POST or None, instance=blog)  # instance 폼의 항목에 맞게 blog에서 데이터를 불러옴
    if form.is_valid():
        # form.save() : form에 내용을 DB에 반영하고 해당 데이터의 객체를 반환(리턴)함.
        blog = form.save()  # DB에 반영
        return redirect(reverse('blog_detail', kwargs={'pk':blog.pk}))

    context = {
        'blog':blog,
        'form':form,
   }

    return render(request, 'blog_update.html', context)

# blog_update.html
{% extends 'base.html' %}
{% block content %}
<form method="POST">
    <h1>블로그 수정</h1>
    {% csrf_token %}
    {{ form.as_p }}
    <button>수정</button>
</form>
{% endblock %}


--------------------------------
# 페이지 기능 (pagination) 구현
--------------------------------

# blog/views.py
def blog_list(request):
    paginator = Paginator(blogs, 10)  # blogs를 10개 단위로 페이지를 만듬
    page = request.GET.get('page')  # 파라미터 값으로 page값이 들어오면 page값 반환. 0이거나 최대페이지를 초과하는 페이지는 마지막 페이지를 반환. 숫자가 아닌값이 들어오면 첫페이지
    page_object = paginator.get_page(page)  # 해당 페이지로 이동

    context = {
        'page_object': page_object,
    }

    return render(request, 'blog_list.html', context)

# blog_list.html
{% for blog in page_object %}
    <p>
        <a href="{% url 'blog_detail' blog.pk %}">
            ({{ blog.id }}) {{ blog.title }} <small>by {{ blog.author.username }}</small> - <small>{{ blog.created_at | date:"Y-m-d"}}</small>
        </a>
    </p>
{% endfor %}

# v1
<div style="text-align:center;">
    {% if page_object.has_previous %}  {# 이전 페이지 존재시 #}
    <a href="?page=1">&laquo; 첫번째</a>
    <a href="?page={{ page_object.previous_page_number }}">이전</a>
    {% endif %}
    <span>
        {# 총 페이지 중에 현재 몇 페이지인지 표시 #}
        Page {{ page_object.number }} of {{ page_object.paginator.num_pages }}
    </span>
    {% if page_object.has_next %} {# 다음 페이지 존재시 #}
        <a href="?page={{ page_object.next_page_number }}">다음</a>
        <a href="?page={{ page_object.paginator.num_pages }}">마지막 &raquo;</a>
    {% endif %}
</div>

# v2
<div style="text-align:center;">
    {% if page_object.has_previous %}  {# 이전 페이지 존재시 #}
        <a href="?page=1">&laquo; 첫번째</a>
        <a href="?page={{ page_object.previous_page_number }}">이전</a>
    {% endif %}

    {# 총 페이지 중에 현재 몇 페이지인지 표시 #}
    {# <span> Page {{ page_object.number }} of {{ page_object.paginator.num_pages }} </span> #}

    {# 현재페이지 -2 > 1 이면 ... #}
    {% if page_object.number|add:-2 > 1 %}
        <a href="?page={{ page_object.number|add:-3 }}">&hellip;</a>
    {% endif %}
    {% for i in page_object.paginator.page_range %}
        {% if page_object.number == i %}
            <span>(현재페이지)</span>
        {# 현재페이지 - 2 <= 현재페이지 <= 현재페이지 + 2 #}
        {% elif page_object.number|add:-2 <= i and i <= page_object.number|add:2 %}
            <a href="?page={{ i }}">{{ i }}</a>
        {% endif %}
    {% endfor %}
    {# 최대페이지 > 현재페이지 + 2 이면 ... #}
    {% if page_object.paginator.num_pages > page_object.number|add:2 %}
        <a href="?page={{ page_object.number|add:3 }}">&hellip;</a>
    {% endif %}

    {% if page_object.has_next %} {# 다음 페이지 존재시 #}
        <a href="?page={{ page_object.next_page_number }}">다음</a>
        <a href="?page={{ page_object.paginator.num_pages }}">마지막 &raquo;</a>
    {% endif %}
</div>


------------------
# 검색 기능 구현
------------------

# blog/views.py
q = request.GET.get('q')
if q:
    blogs = blogs.filter(Q(title__icontains=q) | Q(content__icontains=q))
    # blogs = blogs.filter(title__icontains=q)
    
# blog_list.html
<div style="text-align:center; margin: 20px 0;">
    <form method="get">
        <input name="q" type="text" placeholder="검색어를 입력하세요." value="{% if request.GET.q %}{{ request.GET.q }}{% endif %}">
        <button>검색</button>
    </form>
</div>


------------------
# 삭제 기능 구현
------------------

# blog/views.py
@login_required
@require_http_methods(['POST'])
def blog_delete(request, pk):
    # if request.method != 'POST':
    #     raise Http404

    blog = get_object_or_404(Blog, pk=pk, author=request.user) # pk와 author가 일치하는 데이터만 가져옴
    blog.delete()

    return redirect(reverse('blog_list'))

# blog_detail.html
<a href="{% url 'blog_delete' blog.pk %}">삭제</a>
<form action="{% url 'blog_delete' blog.pk %}" method="POST" style="display:inline">
    {% csrf_token %}
    <button>삭제</button>
</form>