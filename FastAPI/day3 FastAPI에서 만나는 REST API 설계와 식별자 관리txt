미팅 생성 API의 스펙 만들기

실무에서는 구현을 먼저 하는것이 아니라 스펙을 머저 작성하는게 더 좋다.

스펙 + 더미 데이터를 리턴하는  API를 먼저 만들면 동료 프론트엔드 개발자가 작얼을 일찍 시작할 수 있다.

개발 시작전 전체 테스트 실행

ORJSON


## DTO란? (Data Transfer Object)

- data 를 “전달”하기 위한 목적으로 생성한 객체를 의미합니다.
- dto 는 오직 데이터를 “전달”만 해야 하며, 데이터를 수정, 추가, 삭제하면 안됩니다. (수정 추가 삭제를 하는 순간부터 dto 는 dto 가 아니게 됩니다.)
- “정보이론”을 배우신 분들이라면 “정보의 양이 변경된다면” dto 가 아니라고 할 수 있겠습니다.
- pydantic basemodel 을 상속하는 `CreateMeetingResponse` 가 현재 dto 입니다.

## Dto 를 쓰고, Dict 를 쓰지 마세요!
만약 path operation function 에서 `CreateMeetingResponse` 가 아닌 `dict[str, str]` 을 사용한다면 어떻게 될까요?
dict를 사용할 순 있지만 FastAPI의 기능을 제대로 사용할 수 없음.

정리

- 구현 보다 앞서 스펙을 동료들과 확정하고, 스펙 + 더미 response 먼저 만들어 배포하자.
- timeit 을 사용해서 간단한 파이썬 코드조각을 성능테스트 할 수 있다.  성능테스트의 수치는 좋은 방어수단이된다. 합리화 할 수 있다.
- pydantic 으로 dto 를 생성할 수 있다.
- dict 대신 dto 를 사용하자!


# base62

- uuid 와 base62 를 사용하는 방법 (강의에서 선택한 방법)
    
    “고유하고”, “충분히 짧고”, “alphanumeric 인” 식별자를 만드는 방법을 2가지 소개하겠습니다.
    
    첫번째 방법은 python 내장 라이브러리만 사용해서 구현하며, 강의에서 앞으로 이 방법을 사용해서 식별자를 생성해 낼 예정입니다.
    
    - `app/utils/base62.py`
        
        ```python
        import string
        from typing import Final, ClassVar
        
        class Base62:
            BASE: Final[ClassVar[str]] = string.ascii_letters + string.digits
            BASE_LEN: Final[ClassVar[int]] = len(BASE)
        
            @classmethod
            def encode(cls, num: int) -> str:
                if num < 0:
                    raise ValueError(f"{cls}.encode() needs positive integer but you passed: {num}")
        
                if num == 0:
                    return cls.BASE[0]
        
                result = []
                while num:
                    num, remainder = divmod(num, cls.BASE_LEN)
                    result.append(cls.BASE[remainder])
                return "".join(result)
        
        ```
        
    - `Base62.encode()` 를 호출하면 인자로 전달받은 int 가 고유한 문자열 식별자로 변환되도록 만들 것입니다.
    
    base64, base62 등등 base 계열 encoding 방식의 동작 원리는 다음과 같습니다.
    
    1. 결과 값에 들어갈 수 있는 문자, 숫자를 미리 지정합니다. 이 값들의 개수가 64개면 base64 가 되고, 62개면 base62 가 됩니다.
        1. 앞으로 “결과 값에 들어갈 수 있는 문자, 숫자” 가 모두 들어있는 문자열을 `base` 라고 부르겠습니다.
        2. base 의 개수를 `base_len` 이라고 부르겠습니다.
    2. 하나의 정수를 인자로 받습니다.
    3. 정수를 base_len 으로 1번 나눈 후 몫과 나머지를 구합니다.
    4. base 의 “나머지” 번째 값을 결과에 추가합니다.
    5. 몫이 0이 될 때 까지 반복합니다.
    6. 결과를 문자열로 변환해 리턴합니다.


# 디버깅의 중요성:

만약 어느날 악마가 나타나 이 강의의 모든 내용중 “단 하나의 지식” 만 남길 수 있다고 말한다면 주저 없이 “디버깅”을 선택해야 합니다. 디버깅 능력은 그만큼 중요합니다.

저는 디버깅을 못하는 사람중에 개발을 잘하는 사람은 거의 본적이 없고, 개발을 잘하는 사람중에 디버깅을 못하는 사람은 아예 본 적이 없습니다. 

다음은 “디버깅을 통해 배우는 리눅스 커널의 구조와 원리” 라는 책에 나오는 글입니다.

> )91 페이지) 리눅스 개발자뿐만 아니라 다른 분야에 몸담고 있는 소프트웨어 개발자를 만나면 주로 이야기하는 주제가 디버깅입니다. 그중에서 게임계의 레전드 개발자이자 엔지니어인 김포프 님께서 언급하신 ‘디버깅에 대한 생각’을 공유합니다 (괄호 안의 내용은 발언 시점)
> 
> - 프로그래머의 자질은 코딩을 해서 제품을 만들 수 있는 능력이다(1:15)
> - 프로그래머가 갖춰야 할 가장 중요한 능력은 디버깅 스킬이다(2:45)
> - 디버깅을 잘한다는 것은 남의 코드를 잘 읽고 그 코드 속의 로직을 따질 수 있고 그 로직을 단계별로 나눌 수 있는 것이다(3:22)
> - 디버깅을 잘하면 남의 코드를 보는 것이 두렵지 않고 이 과정으로 배우는 것이 정말 많다(4:52)
> - 디버깅을 잘하는 프로그래머를 보면 엄청나게 성장할 것이란 것을 안다(5:01)
> - 정말 코딩을 잘하는 사람 중에 디버깅을 못하는 사람을 본 적이 없다. 디버깅을 잘하는 사람 중에 코딩을 못하는 사람을 본 적이 없다. 디버깅을 못하는 사람 중에 코딩을 잘하는 사람은 (거의) 본 적이 없다. 디버깅을 못하는 사람 중에 설계를 잘하는 사람은 (거의) 본 적이 없다(7:35)
> 
> 소프트웨어 개발자로서 너무 공감이 되고 깊이 새겨야 할 명언인 것 같습니다.
>

### Deterministic

Base62 연산은 “결정적” 입니다.(deterministic) 결정적이라는 말은 같은 입력을 하면 항상 같은 결과가 나온다는 뜻입니다.

예를 들어…

- 덧셈, 곱셈 등은 같은 인자를 넣으면 항상 같은 결과가 나오므로 결정적.
- random 뽑기 같은 연산은 실행할 때마다 결과가 다르므로 결정적이 아님.

입니다.

### 정리

- base62 를 사용해서 uuid4 를 “짧게” 만들 수 있습니다.
- 중단점을 찍고 디버거를 사용하는 방법을 배웠습니다.
    - step over 로 한 줄 앞으로 실행, resume 으로 다음 중단점까지 실행합니다.
    - evaluate expression 을 사용하면 어떤 식도 실행하고 결과를 확인할 수 있습니다.
- 같은 인자를 넣으면 항상 같은 결과가 나오는 특성을 “결정적” 이라고 합니다.


# Sqids

https://sqids.org/ko

Sqids이란 무엇인가요?
Sqids는 숫자로부터 짧은 고유 식별자를 생성할 수 있는 오픈 소스 라이브러리입니다. 이 ID들은 URL에 안전하며 여러 숫자를 인코딩할 수 있으며 일반적인 욕설 단어를 포함하지 않습니다. 더 보기.

이것이 그들이 보이는 모습입니다:

## 기능
🆔
음수가 아닌 숫자로부터 짧은 ID 생성
✅
쉬운 인코딩 및 디코딩
🫣
자동 생성된 ID에는 일반적인 욕설이 포함되지 않음
🎲
셔플된 알파벳을 통한 사용자 정의 ID 지원
🥳
46 통합 (85% 는 새로운 디자인을 사용합니다)
📌
모든 버전은 동일한 ID를 생성함
🍻
허용 라이선스를 가진 소규모 라이브러리

설치
poetry add sqids

설치,버전 확인
pip freeze | grep sqids
